{"name":"Phyloinformatics: Extend PartitionFinder to automatically partition DNA and protein alignments","tagline":"Google Summer of Code 2013 Blog","body":"###The beginning of the coding period\r\nWe are two days into the coding period. Things have progressed smoothly so far. I have a working function for retrieving a Phylip file, running it through PhyML, parsing the site likelihoods, and running them through k-means clustering to split them into two.\r\n\r\nThe tricky part of today's code was dealing with Python's file object. If there are no rate categories included in the analysis, the output starts on a different line than if rate categories are estimated. Because of this, my parser needed to be robust to both types of files. I found that you cannot use readline() and next() one after the other. However, I needed to read the contents of the second line in order to discover which type of input the file was. I wanted to do something like this:\r\n```\r\nwith open(str(new_file)) as new_file:\r\n    new_file.next()\r\n    line2 = new_file.readline()\r\n    # Check to see which file it is\r\n    if line2[0] == \"P\":\r\n        # Move to line 7\r\n    else:\r\n        # Move to line 4\r\n```\r\nAfter consulting the fine folks at StackOverflow, I discovered that you can set a variable equal to newfile.next() and it will read in a string of the line it is leaving. My code then looked similar to this:\r\n```\r\nline2 = new_file.next()\r\nif line2[0] == \"P\":\r\n    for _ in xrange(4):\r\n        new_file.next()\r\nelse:\r\n    new_file.next()\r\n```\r\nVery nice.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}